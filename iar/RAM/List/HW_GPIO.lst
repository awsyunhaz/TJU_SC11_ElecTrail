###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        10/Apr/2016  21:40:49
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\lib\LPLD\HW\HW_GPIO.c
#    Command line =  
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\lib\LPLD\HW\HW_GPIO.c
#        -D LPLD_K60 -lCN
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\RAM\List\
#        -lB
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\RAM\List\
#        -o
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\RAM\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\IAR Systems\Embedded
#        Workbench 7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\app\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\CPU\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\common\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\LPLD\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\LPLD\HW\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\FatFs\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\FatFs\option\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\USB\common\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\USB\driver\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\USB\descriptor\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\USB\class\
#        -Ol -I "D:\IAR Systems\Embedded Workbench 7.0\arm\CMSIS\Include\" -D
#        ARM_MATH_CM4
#    List file    =  
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\RAM\List\HW_GPIO.lst
#    Object file  =  
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\RAM\Obj\HW_GPIO.o
#
###############################################################################

C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\lib\LPLD\HW\HW_GPIO.c
      1          /**
      2          * @file HW_GPIO.c
      3          * @version 3.03[By LPLD]
      4          * @date 2014-2-10
      5          * @brief GPIO底层模块相关函数
      6          *
      7          * 更改建议:不建议修改
      8          *
      9          * 版权所有:北京拉普兰德电子技术有限公司
     10          * http://www.lpld.cn
     11          * mail:support@lpld.cn
     12          *
     13          * @par
     14          * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     15          * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     16          * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     17          * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     18          * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     19          * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     20          * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     21          */
     22          #include "common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable9  ;; 0xe000e100
   \   0000000A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000C   0x0940             LSRS     R0,R0,#+5
   \   0000000E   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable9_1  ;; 0xe000e180
   \   0000000A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000C   0x0940             LSRS     R0,R0,#+5
   \   0000000E   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return
     23          #include "HW_GPIO.h"
     24          
     25          
     26          //用户自定义中断服务函数数组

   \                                 In section .bss, align 4
     27          GPIO_ISR_CALLBACK GPIO_ISR[5];
   \                     GPIO_ISR:
   \   00000000                      DS8 20
     28          
     29          /*
     30          * LPLD_GPIO_Init
     31          * GPIO通用初始化函数
     32          * 
     33          * 参数:
     34          *    gpio_init_structure--GPIO初始化结构体，
     35          *                        具体定义见GPIO_InitTypeDef
     36          *
     37          * 输出:
     38          *    0--配置错误
     39          *    1--配置成功
     40          */

   \                                 In section .text, align 2, keep-with-next
     41          uint8 LPLD_GPIO_Init(GPIO_InitTypeDef gpio_init_structure)
     42          {
   \                     LPLD_GPIO_Init: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB4F0             PUSH     {R4-R7}
     43            uint8 i;
     44            PORT_Type *portx;
     45            uint32 pcr = PORT_PCR_MUX(1)| gpio_init_structure.GPIO_PinControl; 
   \   00000004   0x9806             LDR      R0,[SP, #+24]
   \   00000006   0xF450 0x7080      ORRS     R0,R0,#0x100
     46            GPIO_Type *ptx = gpio_init_structure.GPIO_PTx;
   \   0000000A   0x9B04             LDR      R3,[SP, #+16]
     47            uint32 pins = gpio_init_structure.GPIO_Pins;
   \   0000000C   0x9905             LDR      R1,[SP, #+20]
     48            uint8 dir = gpio_init_structure.GPIO_Dir;
   \   0000000E   0xF89D 0x701C      LDRB     R7,[SP, #+28]
     49            uint8 output = gpio_init_structure.GPIO_Output;
   \   00000012   0xF89D 0x401D      LDRB     R4,[SP, #+29]
     50            GPIO_ISR_CALLBACK isr_func = gpio_init_structure.GPIO_Isr;
   \   00000016   0x9A08             LDR      R2,[SP, #+32]
     51            
     52            //参数检查
     53            ASSERT( ptx <= PTE);                  //判断端口
     54            ASSERT( dir <= 1 );                   //判断方向
     55            ASSERT( output <= 1 );                //判断输出电平状态
     56            
     57            if(ptx == PTA)
   \   00000018   0x....             LDR.N    R5,??DataTable9_2  ;; 0x400ff000
   \   0000001A   0x42AB             CMP      R3,R5
   \   0000001C   0xD10C             BNE.N    ??LPLD_GPIO_Init_0
     58            {
     59              portx = PORTA;  
   \   0000001E   0x....             LDR.N    R6,??DataTable9_3  ;; 0x40049000
     60              i = 0;
   \   00000020   0x2500             MOVS     R5,#+0
     61            }
     62            else if(ptx == PTB) 
     63            {
     64              portx = PORTB;
     65              i = 1;
     66            }
     67            else if(ptx == PTC) 
     68            {
     69              portx = PORTC;
     70              i = 2;
     71            }
     72            else if(ptx == PTD) 
     73            {
     74              portx = PORTD;
     75              i = 3; 
     76            }
     77            else if(ptx == PTE) 
     78            {
     79              portx = PORTE;
     80              i = 4;
     81            }
     82            else
     83              return 0;
     84            
     85            //输入或输出设置
     86            if(dir==DIR_OUTPUT)
   \                     ??LPLD_GPIO_Init_1: (+1)
   \   00000022   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000024   0x2F01             CMP      R7,#+1
   \   00000026   0xD123             BNE.N    ??LPLD_GPIO_Init_2
     87            {
     88              ptx->PDDR |= pins;
   \   00000028   0x695F             LDR      R7,[R3, #+20]
   \   0000002A   0x430F             ORRS     R7,R1,R7
   \   0000002C   0x615F             STR      R7,[R3, #+20]
     89              //设置初始输出
     90              if(output==OUTPUT_H)
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x2C01             CMP      R4,#+1
   \   00000032   0xD11B             BNE.N    ??LPLD_GPIO_Init_3
     91              {
     92                ptx->PSOR = pins; 
   \   00000034   0x6059             STR      R1,[R3, #+4]
   \   00000036   0xE01E             B.N      ??LPLD_GPIO_Init_4
     93              }
   \                     ??LPLD_GPIO_Init_0: (+1)
   \   00000038   0x....             LDR.N    R5,??DataTable9_4  ;; 0x400ff040
   \   0000003A   0x42AB             CMP      R3,R5
   \   0000003C   0xD102             BNE.N    ??LPLD_GPIO_Init_5
   \   0000003E   0x....             LDR.N    R6,??DataTable9_5  ;; 0x4004a000
   \   00000040   0x2501             MOVS     R5,#+1
   \   00000042   0xE7EE             B.N      ??LPLD_GPIO_Init_1
   \                     ??LPLD_GPIO_Init_5: (+1)
   \   00000044   0x....             LDR.N    R5,??DataTable9_6  ;; 0x400ff080
   \   00000046   0x42AB             CMP      R3,R5
   \   00000048   0xD102             BNE.N    ??LPLD_GPIO_Init_6
   \   0000004A   0x....             LDR.N    R6,??DataTable9_7  ;; 0x4004b000
   \   0000004C   0x2502             MOVS     R5,#+2
   \   0000004E   0xE7E8             B.N      ??LPLD_GPIO_Init_1
   \                     ??LPLD_GPIO_Init_6: (+1)
   \   00000050   0x....             LDR.N    R5,??DataTable9_8  ;; 0x400ff0c0
   \   00000052   0x42AB             CMP      R3,R5
   \   00000054   0xD102             BNE.N    ??LPLD_GPIO_Init_7
   \   00000056   0x....             LDR.N    R6,??DataTable9_9  ;; 0x4004c000
   \   00000058   0x2503             MOVS     R5,#+3
   \   0000005A   0xE7E2             B.N      ??LPLD_GPIO_Init_1
   \                     ??LPLD_GPIO_Init_7: (+1)
   \   0000005C   0x....             LDR.N    R5,??DataTable9_10  ;; 0x400ff100
   \   0000005E   0x42AB             CMP      R3,R5
   \   00000060   0xD102             BNE.N    ??LPLD_GPIO_Init_8
   \   00000062   0x....             LDR.N    R6,??DataTable9_11  ;; 0x4004d000
   \   00000064   0x2504             MOVS     R5,#+4
   \   00000066   0xE7DC             B.N      ??LPLD_GPIO_Init_1
   \                     ??LPLD_GPIO_Init_8: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xE019             B.N      ??LPLD_GPIO_Init_9
     94              else
     95              {
     96                ptx->PCOR = pins;
   \                     ??LPLD_GPIO_Init_3: (+1)
   \   0000006C   0x6099             STR      R1,[R3, #+8]
   \   0000006E   0xE002             B.N      ??LPLD_GPIO_Init_4
     97              }
     98            }
     99            else
    100            { 
    101              ptx->PDDR &= ~(pins);
   \                     ??LPLD_GPIO_Init_2: (+1)
   \   00000070   0x695C             LDR      R4,[R3, #+20]
   \   00000072   0x438C             BICS     R4,R4,R1
   \   00000074   0x615C             STR      R4,[R3, #+20]
    102            }
    103            
    104            //配置所选引脚的控制寄存器
    105            for(uint8 i=0; i<32; i++)
   \                     ??LPLD_GPIO_Init_4: (+1)
   \   00000076   0x2300             MOVS     R3,#+0
   \   00000078   0xE007             B.N      ??LPLD_GPIO_Init_10
    106            {
    107              if(pins&(1ul<<i))
   \                     ??LPLD_GPIO_Init_11: (+1)
   \   0000007A   0xFA31 0xF403      LSRS     R4,R1,R3
   \   0000007E   0x07E4             LSLS     R4,R4,#+31
   \   00000080   0xD502             BPL.N    ??LPLD_GPIO_Init_12
    108              {
    109                portx->PCR[i] = pcr;
   \   00000082   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000084   0xF846 0x0023      STR      R0,[R6, R3, LSL #+2]
    110              }
    111            }
   \                     ??LPLD_GPIO_Init_12: (+1)
   \   00000088   0x1C5B             ADDS     R3,R3,#+1
   \                     ??LPLD_GPIO_Init_10: (+1)
   \   0000008A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000008C   0x2B20             CMP      R3,#+32
   \   0000008E   0xDBF4             BLT.N    ??LPLD_GPIO_Init_11
    112            
    113            if(isr_func!=NULL)
   \   00000090   0x0010             MOVS     R0,R2
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD003             BEQ.N    ??LPLD_GPIO_Init_13
    114              GPIO_ISR[i] = isr_func;
   \   00000096   0x....             LDR.N    R0,??DataTable9_12
   \   00000098   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009A   0xF840 0x2025      STR      R2,[R0, R5, LSL #+2]
    115            
    116            return 1;
   \                     ??LPLD_GPIO_Init_13: (+1)
   \   0000009E   0x2001             MOVS     R0,#+1
   \                     ??LPLD_GPIO_Init_9: (+1)
   \   000000A0   0xBCF0             POP      {R4-R7}
   \   000000A2   0xB004             ADD      SP,SP,#+16
   \   000000A4   0x4770             BX       LR               ;; return
    117          }
    118          /*
    119          * GPIO
    120          * 简易初始化GPIO
    121          * 参数:
    122          *    ptxn--端口号枚举
    123          *      |__PTA0~PTE31 
    124          *    dir--端口方向
    125          *      |__0--输入
    126          *      |__1--输出
    127          *
    128          * 输出:无
    129          *
    130          */

   \                                 In section .text, align 2, keep-with-next
    131          void GPIO(PortPinsEnum_Type ptxn,uint8 dir)
    132          {
   \                     GPIO: (+1)
   \   00000000   0xB410             PUSH     {R4}
    133            uint8 x = ptxn >> 5;
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x0942             LSRS     R2,R0,#+5
    134            uint8 i = ptxn & 0x1F;
   \   00000006   0xF010 0x001F      ANDS     R0,R0,#0x1F
    135            
    136            GPIO_Type *ptx = (GPIO_Type*)(PTA_BASE+(x<<6));
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0x0193             LSLS     R3,R2,#+6
   \   0000000E   0xF103 0x4380      ADD      R3,R3,#+1073741824
   \   00000012   0xF513 0x237F      ADDS     R3,R3,#+1044480
    137            PORT_Type *portx = (PORT_Type*)(PORTA_BASE+(x<<12));
   \   00000016   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000018   0x0312             LSLS     R2,R2,#+12
   \   0000001A   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   0000001E   0xF512 0x2292      ADDS     R2,R2,#+299008
    138            
    139            DDR(ptx,i)=dir;
   \   00000022   0x3314             ADDS     R3,R3,#+20
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x0084             LSLS     R4,R0,#+2
   \   00000028   0xEB14 0x1343      ADDS     R3,R4,R3, LSL #+5
   \   0000002C   0xF113 0x4384      ADDS     R3,R3,#+1107296256
   \   00000030   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000032   0x6019             STR      R1,[R3, #+0]
    140            portx->PCR[i] = PORT_PCR_MUX(1);
   \   00000034   0xF44F 0x7180      MOV      R1,#+256
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    141          }
   \   0000003E   0xBC10             POP      {R4}
   \   00000040   0x4770             BX       LR               ;; return
    142          /*
    143          * LPLD_GPIO_EnableIrq
    144          * 使能GPIO外部中断
    145          * 
    146          * 参数:
    147          *    gpio_init_structure--GPIO初始化结构体，
    148          *                        具体定义见GPIO_InitTypeDef
    149          *
    150          * 输出:
    151          *    0--配置错误
    152          *    1--配置成功
    153          *
    154          */

   \                                 In section .text, align 2, keep-with-next
    155          uint8 LPLD_GPIO_EnableIrq(GPIO_InitTypeDef gpio_init_structure)
    156          {
   \                     LPLD_GPIO_EnableIrq: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB580             PUSH     {R7,LR}
    157            uint8 i;
    158            GPIO_Type *ptx = gpio_init_structure.GPIO_PTx;
   \   00000004   0x9802             LDR      R0,[SP, #+8]
    159            
    160            //参数检查
    161            ASSERT( ptx <= PTE);                  //判断端口
    162            
    163            if(ptx == PTA)
   \   00000006   0x....             LDR.N    R1,??DataTable9_2  ;; 0x400ff000
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD101             BNE.N    ??LPLD_GPIO_EnableIrq_0
    164              i = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE00F             B.N      ??LPLD_GPIO_EnableIrq_1
    165            else if(ptx == PTB) 
   \                     ??LPLD_GPIO_EnableIrq_0: (+1)
   \   00000010   0x....             LDR.N    R1,??DataTable9_4  ;; 0x400ff040
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD101             BNE.N    ??LPLD_GPIO_EnableIrq_2
    166              i = 1;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE00A             B.N      ??LPLD_GPIO_EnableIrq_1
    167            else if(ptx == PTC) 
   \                     ??LPLD_GPIO_EnableIrq_2: (+1)
   \   0000001A   0x....             LDR.N    R1,??DataTable9_6  ;; 0x400ff080
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD101             BNE.N    ??LPLD_GPIO_EnableIrq_3
    168              i = 2;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xE005             B.N      ??LPLD_GPIO_EnableIrq_1
    169            else if(ptx == PTD) 
   \                     ??LPLD_GPIO_EnableIrq_3: (+1)
   \   00000024   0x....             LDR.N    R1,??DataTable9_8  ;; 0x400ff0c0
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD101             BNE.N    ??LPLD_GPIO_EnableIrq_4
    170              i = 3;
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0xE000             B.N      ??LPLD_GPIO_EnableIrq_1
    171            else
    172              i = 4;
   \                     ??LPLD_GPIO_EnableIrq_4: (+1)
   \   0000002E   0x2004             MOVS     R0,#+4
    173            
    174            enable_irq((IRQn_Type)(i + PORTA_IRQn));
   \                     ??LPLD_GPIO_EnableIrq_1: (+1)
   \   00000030   0x3057             ADDS     R0,R0,#+87
   \   00000032   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000034   0x.... 0x....      BL       NVIC_EnableIRQ
    175            
    176            return 1;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xBC02             POP      {R1}
   \   0000003C   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    177          }
    178          
    179          /*
    180          * LPLD_GPIO_DisableIrq
    181          * 禁用GPIO外部中断
    182          * 
    183          * 参数:
    184          *    gpio_init_structure--GPIO初始化结构体，
    185          *                        具体定义见GPIO_InitTypeDef
    186          *
    187          * 输出:
    188          *    0--配置错误
    189          *    1--配置成功
    190          *
    191          */

   \                                 In section .text, align 2, keep-with-next
    192          uint8 LPLD_GPIO_DisableIrq(GPIO_InitTypeDef gpio_init_structure)
    193          {
   \                     LPLD_GPIO_DisableIrq: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB580             PUSH     {R7,LR}
    194            uint8 i;
    195            GPIO_Type *ptx = gpio_init_structure.GPIO_PTx;
   \   00000004   0x9802             LDR      R0,[SP, #+8]
    196            
    197            //参数检查
    198            ASSERT( ptx <= PTE);                  //判断端口
    199            
    200            if(ptx == PTA)
   \   00000006   0x....             LDR.N    R1,??DataTable9_2  ;; 0x400ff000
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD101             BNE.N    ??LPLD_GPIO_DisableIrq_0
    201              i = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE00F             B.N      ??LPLD_GPIO_DisableIrq_1
    202            else if(ptx == PTB) 
   \                     ??LPLD_GPIO_DisableIrq_0: (+1)
   \   00000010   0x....             LDR.N    R1,??DataTable9_4  ;; 0x400ff040
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD101             BNE.N    ??LPLD_GPIO_DisableIrq_2
    203              i = 1;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE00A             B.N      ??LPLD_GPIO_DisableIrq_1
    204            else if(ptx == PTC) 
   \                     ??LPLD_GPIO_DisableIrq_2: (+1)
   \   0000001A   0x....             LDR.N    R1,??DataTable9_6  ;; 0x400ff080
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD101             BNE.N    ??LPLD_GPIO_DisableIrq_3
    205              i = 2;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xE005             B.N      ??LPLD_GPIO_DisableIrq_1
    206            else if(ptx == PTD) 
   \                     ??LPLD_GPIO_DisableIrq_3: (+1)
   \   00000024   0x....             LDR.N    R1,??DataTable9_8  ;; 0x400ff0c0
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD101             BNE.N    ??LPLD_GPIO_DisableIrq_4
    207              i = 3;
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0xE000             B.N      ??LPLD_GPIO_DisableIrq_1
    208            else
    209              i = 4;
   \                     ??LPLD_GPIO_DisableIrq_4: (+1)
   \   0000002E   0x2004             MOVS     R0,#+4
    210            
    211            disable_irq((IRQn_Type)(i + PORTA_IRQn));
   \                     ??LPLD_GPIO_DisableIrq_1: (+1)
   \   00000030   0x3057             ADDS     R0,R0,#+87
   \   00000032   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000034   0x.... 0x....      BL       NVIC_DisableIRQ
    212            
    213            return 1;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xBC02             POP      {R1}
   \   0000003C   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    214          }
    215          
    216          /*
    217          * LPLD_GPIO_Ouptut
    218          * 设置GPIO端口0~31位的输出
    219          * 
    220          * 参数:
    221          *    ptx--端口号
    222          *      |__PTA        --Port A
    223          *      |__PTB        --Port B
    224          *      |__PTC        --Port C
    225          *      |__PTD        --Port D
    226          *      |__PTE        --Port E
    227          *    data32--输出数据
    228          *      |__0x00000000~0xFFFFFFFF--低到高代表GPIO口的第0~31位数据
    229          *
    230          * 输出:
    231          *
    232          */

   \                                 In section .text, align 2, keep-with-next
    233          __INLINE void LPLD_GPIO_Output(GPIO_Type *ptx, uint32 data32)
    234          { 
    235            ptx->PDOR = data32;
   \                     LPLD_GPIO_Output: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
    236          }
   \   00000002   0x4770             BX       LR               ;; return
    237          
    238          /*
    239          * LPLD_GPIO_Ouptut_b
    240          * 设置GPIO端口一位的输出
    241          * 
    242          * 参数:
    243          *    ptx--端口号
    244          *      |__PTA        --Port A
    245          *      |__PTB        --Port B
    246          *      |__PTC        --Port C
    247          *      |__PTD        --Port D
    248          *      |__PTE        --Port E
    249          *    lsb_num--端口引脚位数编号
    250          *      |__0~31       --GPIO口的第0~31位
    251          *    data1--输出数据
    252          *      |__0          --输出低电平
    253          *      |__1          --输出高电平
    254          *
    255          * 输出:
    256          *
    257          */

   \                                 In section .text, align 2, keep-with-next
    258          __INLINE void LPLD_GPIO_Output_b(GPIO_Type *ptx, uint32 lsb_num, uint8 data1)
    259          {
   \                     LPLD_GPIO_Output_b: (+1)
   \   00000000   0xB410             PUSH     {R4}
    260            ptx->PDOR = (ptx->PDOR & ~(0x01L<<lsb_num)) | (uint32)data1<<lsb_num;
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x2401             MOVS     R4,#+1
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000010   0x4319             ORRS     R1,R1,R3
   \   00000012   0x6001             STR      R1,[R0, #+0]
    261          }
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return
    262          
    263          /*
    264          * LPLD_GPIO_Ouptut_8b
    265          * 设置GPIO端口8位的输出
    266          * 
    267          * 参数:
    268          *    ptx--端口号
    269          *      |__PTA        --Port A
    270          *      |__PTB        --Port B
    271          *      |__PTC        --Port C
    272          *      |__PTD        --Port D
    273          *      |__PTE        --Port E
    274          *    lsb_num--代表8个端口引脚的最低位数编号
    275          *      |__0~24       --GPIO口的第0~24位
    276          *    data8--输出数据
    277          *      |__0x00~0xFF--代表GPIO口输出的8位数据
    278          *
    279          * 输出:
    280          *
    281          */

   \                                 In section .text, align 2, keep-with-next
    282          __INLINE void LPLD_GPIO_Output_8b(GPIO_Type *ptx, uint8 lsb_num, uint8 data8)
    283          {
   \                     LPLD_GPIO_Output_8b: (+1)
   \   00000000   0xB410             PUSH     {R4}
    284            ptx->PDOR = (ptx->PDOR & ~(0xFFL<<lsb_num)) | (uint32)data8<<lsb_num;
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x24FF             MOVS     R4,#+255
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000010   0x4319             ORRS     R1,R1,R3
   \   00000012   0x6001             STR      R1,[R0, #+0]
    285          }
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return
    286          
    287          /*
    288          * LPLD_GPIO_Toggle
    289          * 设置GPIO端口0~31的电平翻转
    290          * 
    291          * 参数:
    292          *    ptx--端口号
    293          *      |__PTA        --Port A
    294          *      |__PTB        --Port B
    295          *      |__PTC        --Port C
    296          *      |__PTD        --Port D
    297          *      |__PTE        --Port E
    298          *    data32--翻转数据
    299          *      |__0x00000000~0xFFFFFFFF--低到高代表GPIO口的第0~31位的翻转，1为反转，0为保持不变。
    300          *
    301          * 输出:
    302          *
    303          */

   \                                 In section .text, align 2, keep-with-next
    304          __INLINE void LPLD_GPIO_Toggle(GPIO_Type *ptx, uint32 data32)
    305          {  
    306            ptx->PTOR = data32;
   \                     LPLD_GPIO_Toggle: (+1)
   \   00000000   0x60C1             STR      R1,[R0, #+12]
    307          }
   \   00000002   0x4770             BX       LR               ;; return
    308          
    309          /*
    310          * LPLD_GPIO_Toggle_b
    311          * 设置GPIO端口一位的翻转
    312          * 
    313          * 参数:
    314          *    ptx--端口号
    315          *      |__PTA        --Port A
    316          *      |__PTB        --Port B
    317          *      |__PTC        --Port C
    318          *      |__PTD        --Port D
    319          *      |__PTE        --Port E
    320          *    lsb_num--端口引脚位数编号
    321          *      |__0~31       --GPIO口的第0~31位
    322          *
    323          * 输出:
    324          *
    325          */

   \                                 In section .text, align 2, keep-with-next
    326          __INLINE void LPLD_GPIO_Toggle_b(GPIO_Type *ptx, uint8 lsb_num)
    327          {  
    328            ptx->PTOR = 0x01L<<lsb_num;
   \                     LPLD_GPIO_Toggle_b: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000006   0x60C1             STR      R1,[R0, #+12]
    329          }
   \   00000008   0x4770             BX       LR               ;; return
    330          
    331          /*
    332          * LPLD_GPIO_Toggle_8b
    333          * 设置GPIO端口8位的翻转
    334          * 
    335          * 参数:
    336          *    ptx--端口号
    337          *      |__PTA        --Port A
    338          *      |__PTB        --Port B
    339          *      |__PTC        --Port C
    340          *      |__PTD        --Port D
    341          *      |__PTE        --Port E
    342          *    lsb_num--代表8个端口引脚的最低位数编号
    343          *      |__0~24       --GPIO口的第0~24位
    344          *    data8--输出数据
    345          *      |__0x00~0xFF--代表GPIO口输出的8位数据
    346          *
    347          * 输出:
    348          *
    349          */

   \                                 In section .text, align 2, keep-with-next
    350          __INLINE void LPLD_GPIO_Toggle_8b(GPIO_Type *ptx, uint8 lsb_num, uint8 data8)
    351          {
    352            ptx->PTOR = (uint32)data8<<lsb_num;
   \                     LPLD_GPIO_Toggle_8b: (+1)
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000006   0x60C1             STR      R1,[R0, #+12]
    353          }
   \   00000008   0x4770             BX       LR               ;; return
    354          
    355          /*
    356          * LPLD_GPIO_Input
    357          * 取得GPIO口0~31位的数据
    358          * 
    359          * 参数:
    360          *    ptx--端口号
    361          *      |__PTA        --Port A
    362          *      |__PTB        --Port B
    363          *      |__PTC        --Port C
    364          *      |__PTD        --Port D
    365          *      |__PTE        --Port E
    366          *
    367          * 输出:
    368          *    指定GPIO口的32位输入
    369          *
    370          */

   \                                 In section .text, align 2, keep-with-next
    371          __INLINE uint32 LPLD_GPIO_Input(GPIO_Type *ptx)
    372          {
    373            return ptx->PDIR;
   \                     LPLD_GPIO_Input: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x4770             BX       LR               ;; return
    374          }
    375          
    376          /*
    377          * LPLD_GPIO_Input_b
    378          * 取得GPIO口某一位的数据
    379          * 
    380          * 参数:
    381          *    ptx--端口号
    382          *      |__PTA        --Port A
    383          *      |__PTB        --Port B
    384          *      |__PTC        --Port C
    385          *      |__PTD        --Port D
    386          *      |__PTE        --Port E
    387          *    lsb_num--端口引脚位数编号
    388          *      |__0~31       --GPIO口的第0~31位
    389          *
    390          * 输出:
    391          *    指定GPIO口的指定位数的电平
    392          *
    393          */

   \                                 In section .text, align 2, keep-with-next
    394          __INLINE uint8 LPLD_GPIO_Input_b(GPIO_Type *ptx, uint8 lsb_num)
    395          {  
    396            return (uint8)((ptx->PDIR>>lsb_num)&0x01L);
   \                     LPLD_GPIO_Input_b: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x40C8             LSRS     R0,R0,R1
   \   00000004   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000008   0x4770             BX       LR               ;; return
    397          }
    398          
    399          /*
    400          * LPLD_GPIO_Input_8b
    401          * 取得GPIO端口8位数据的输入
    402          * 
    403          * 参数:
    404          *    ptx--端口号
    405          *      |__PTA        --Port A
    406          *      |__PTB        --Port B
    407          *      |__PTC        --Port C
    408          *      |__PTD        --Port D
    409          *      |__PTE        --Port E
    410          *    lsb_num--代表8个端口引脚的最低位数编号
    411          *      |__0~24       --GPIO口的第0~24位
    412          *
    413          * 输出:
    414          *    指定GPIO口的8位数据的电平
    415          *
    416          */

   \                                 In section .text, align 2, keep-with-next
    417          __INLINE uint8 LPLD_GPIO_Input_8b(GPIO_Type *ptx, uint8 lsb_num)
    418          {
    419            return (uint8)((ptx->PDIR>>lsb_num)&0xFFL);
   \                     LPLD_GPIO_Input_8b: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x40C8             LSRS     R0,R0,R1
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x4770             BX       LR               ;; return
    420          }
    421          
    422          /*
    423          * PORTA--PORTE中断处理函数
    424          * 与启动文件startup_K60.s中的中断向量表关联
    425          * 用户无需修改，程序自动进入对应通道中断函数
    426          */

   \                                 In section .text, align 2, keep-with-next
    427          void PORTA_IRQHandler(void)
    428          {
   \                     PORTA_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    429          #if (UCOS_II > 0u)
    430            OS_CPU_SR  cpu_sr = 0u;
    431            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    432            OSIntEnter();
    433            OS_EXIT_CRITICAL();
    434          #endif
    435            
    436            //调用用户自定义中断服务
    437            GPIO_ISR[0](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    438            PORTA->ISFR =0xFFFFFFFF;
   \   00000008   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_13  ;; 0x400490a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    439            
    440          #if (UCOS_II > 0u)
    441            OSIntExit();          //告知系统此时即将离开中断服务子函数
    442          #endif
    443          }//           ;87:  PORT A interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    444          

   \                                 In section .text, align 2, keep-with-next
    445          void PORTB_IRQHandler(void)
    446          {
   \                     PORTB_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    447          #if (UCOS_II > 0u)
    448            OS_CPU_SR  cpu_sr = 0u;
    449            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    450            OSIntEnter();
    451            OS_EXIT_CRITICAL();
    452          #endif
    453            
    454            //调用用户自定义中断服务
    455            GPIO_ISR[1](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x6840             LDR      R0,[R0, #+4]
   \   00000006   0x4780             BLX      R0
    456            PORTB->ISFR =0xFFFFFFFF;
   \   00000008   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_14  ;; 0x4004a0a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    457            
    458          #if (UCOS_II > 0u)
    459            OSIntExit();          //告知系统此时即将离开中断服务子函数
    460          #endif
    461          }//           ;88:  PORT B interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    462          

   \                                 In section .text, align 2, keep-with-next
    463          void PORTC_IRQHandler(void)
    464          {
   \                     PORTC_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    465          #if (UCOS_II > 0u)
    466            OS_CPU_SR  cpu_sr = 0u;
    467            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    468            OSIntEnter();
    469            OS_EXIT_CRITICAL();
    470          #endif
    471            
    472            //调用用户自定义中断服务
    473            GPIO_ISR[2](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x6880             LDR      R0,[R0, #+8]
   \   00000006   0x4780             BLX      R0
    474            PORTC->ISFR =0xFFFFFFFF;
   \   00000008   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_15  ;; 0x4004b0a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    475            
    476          #if (UCOS_II > 0u)
    477            OSIntExit();          //告知系统此时即将离开中断服务子函数
    478          #endif
    479          }//           ;89:  PORT C interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    480          

   \                                 In section .text, align 2, keep-with-next
    481          void PORTD_IRQHandler(void)
    482          {
   \                     PORTD_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    483          #if (UCOS_II > 0u)
    484            OS_CPU_SR  cpu_sr = 0u;
    485            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    486            OSIntEnter();
    487            OS_EXIT_CRITICAL();
    488          #endif
    489            
    490            //调用用户自定义中断服务
    491            GPIO_ISR[3](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0x4780             BLX      R0
    492            PORTD->ISFR =0xFFFFFFFF;
   \   00000008   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_16  ;; 0x4004c0a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    493            
    494          #if (UCOS_II > 0u)
    495            OSIntExit();          //告知系统此时即将离开中断服务子函数
    496          #endif
    497          }//           ;90:  PORT D interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    498          

   \                                 In section .text, align 2, keep-with-next
    499          void PORTE_IRQHandler(void)
    500          {
   \                     PORTE_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    501          #if (UCOS_II > 0u)
    502            OS_CPU_SR  cpu_sr = 0u;
    503            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    504            OSIntEnter();
    505            OS_EXIT_CRITICAL();
    506          #endif
    507            
    508            //调用用户自定义中断服务
    509            GPIO_ISR[4](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x6900             LDR      R0,[R0, #+16]
   \   00000006   0x4780             BLX      R0
    510            PORTE->ISFR =0xFFFFFFFF;
   \   00000008   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_17  ;; 0x4004d0a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    511            
    512          #if (UCOS_II > 0u)
    513            OSIntExit();          //告知系统此时即将离开中断服务子函数
    514          #endif
    515          }//           ;91:  PORT E interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x400FF000         DC32     0x400ff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x40049000         DC32     0x40049000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x400FF040         DC32     0x400ff040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x4004A000         DC32     0x4004a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x400FF080         DC32     0x400ff080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x4004B000         DC32     0x4004b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x400FF0C0         DC32     0x400ff0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x4004C000         DC32     0x4004c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x400FF100         DC32     0x400ff100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x4004D000         DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x........         DC32     GPIO_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x400490A0         DC32     0x400490a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x4004A0A0         DC32     0x4004a0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0x4004B0A0         DC32     0x4004b0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0x4004C0A0         DC32     0x4004c0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0x4004D0A0         DC32     0x4004d0a0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   GPIO
      24   LPLD_GPIO_DisableIrq
        24   -> NVIC_DisableIRQ
      24   LPLD_GPIO_EnableIrq
        24   -> NVIC_EnableIRQ
      32   LPLD_GPIO_Init
       0   LPLD_GPIO_Input
       0   LPLD_GPIO_Input_8b
       0   LPLD_GPIO_Input_b
       0   LPLD_GPIO_Output
       4   LPLD_GPIO_Output_8b
       4   LPLD_GPIO_Output_b
       0   LPLD_GPIO_Toggle
       0   LPLD_GPIO_Toggle_8b
       0   LPLD_GPIO_Toggle_b
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
       8   PORTA_IRQHandler
         8   -- Indirect call
       8   PORTB_IRQHandler
         8   -- Indirect call
       8   PORTC_IRQHandler
         8   -- Indirect call
       8   PORTD_IRQHandler
         8   -- Indirect call
       8   PORTE_IRQHandler
         8   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      66  GPIO
      20  GPIO_ISR
      64  LPLD_GPIO_DisableIrq
      64  LPLD_GPIO_EnableIrq
     166  LPLD_GPIO_Init
       4  LPLD_GPIO_Input
       8  LPLD_GPIO_Input_8b
      10  LPLD_GPIO_Input_b
       4  LPLD_GPIO_Output
      24  LPLD_GPIO_Output_8b
      24  LPLD_GPIO_Output_b
       4  LPLD_GPIO_Toggle
      10  LPLD_GPIO_Toggle_8b
      10  LPLD_GPIO_Toggle_b
      20  NVIC_DisableIRQ
      20  NVIC_EnableIRQ
      18  PORTA_IRQHandler
      18  PORTB_IRQHandler
      18  PORTC_IRQHandler
      18  PORTD_IRQHandler
      18  PORTE_IRQHandler

 
  20 bytes in section .bss
 660 bytes in section .text
 
 660 bytes of CODE memory
  20 bytes of DATA memory

Errors: none
Warnings: none
