###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        10/Apr/2016  21:41:16
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\lib\LPLD\HW\HW_I2C.c
#    Command line =  
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\lib\LPLD\HW\HW_I2C.c
#        -D LPLD_K60 -lCN
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\RAM\List\
#        -lB
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\RAM\List\
#        -o
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\RAM\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\IAR Systems\Embedded
#        Workbench 7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\app\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\CPU\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\common\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\LPLD\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\LPLD\HW\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\FatFs\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\FatFs\option\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\USB\common\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\USB\driver\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\USB\descriptor\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\..\..\..\lib\USB\class\
#        -Ol -I "D:\IAR Systems\Embedded Workbench 7.0\arm\CMSIS\Include\" -D
#        ARM_MATH_CM4
#    List file    =  
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\RAM\List\HW_I2C.lst
#    Object file  =  
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail\iar\RAM\Obj\HW_I2C.o
#
###############################################################################

C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\lib\LPLD\HW\HW_I2C.c
      1          /*
      2           * @file HW_I2C.c
      3           * @version 3.02[By LPLD]
      4           * @date 2013-11-22
      5           * @brief I2C底层模块相关函数
      6           *
      7           * 更改建议:不建议修改
      8           *
      9           * 版权所有:北京拉普兰德电子技术有限公司
     10           * http://www.lpld.cn
     11           * mail:support@lpld.cn
     12           *
     13           * @par
     14           * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     15           * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     16           * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     17           * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     18           * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     19           * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     20           * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     21           */
     22          
     23          #include "common.h"
     24          #include "HW_I2C.h"
     25          
     26          //用户自定义中断服务函数数组
     27          I2C_ISR_CALLBACK I2C_ISR[2];
     28          
     29          /*
     30           * LPLD_I2C_Init
     31           * I2C通用初始化函数，在该函数中选择I2C通道，选择I2C SCK总线频率，
     32           * 选择I2C SDA 和 I2C SCL的引脚，配置I2C的中断回调函数
     33           * 
     34           * 参数:
     35           *    I2C_InitTypeDef--i2c_init_structure
     36           *                     具体定义见I2C_InitTypeDef
     37           * 输出:
     38           *    0--配置错误
     39           *    1--配置成功
     40           */
     41          uint8 LPLD_I2C_Init(I2C_InitTypeDef i2c_init_structure)
     42          {
     43            I2C_Type *i2cx = i2c_init_structure.I2C_I2Cx;
     44            uint8 bus_speed = i2c_init_structure.I2C_ICR;
     45            PortPinsEnum_Type scl_pin = i2c_init_structure.I2C_SclPin;
     46            PortPinsEnum_Type sda_pin = i2c_init_structure.I2C_SdaPin;
     47            I2C_ISR_CALLBACK isr_func = i2c_init_structure.I2C_Isr;
     48            boolean ode = i2c_init_structure.I2C_OpenDrainEnable;
     49            uint8 ode_mask = 0;
     50          
     51            //参数检查，判断SCL频率
     52            ASSERT( bus_speed <= 0x3F);
     53            
     54            if(ode == TRUE)
     55            {
     56              ode_mask = PORT_PCR_ODE_MASK;
     57            }
     58          
     59            if(i2cx == I2C0)
     60            {
     61              SIM->SCGC4 |= SIM_SCGC4_I2C0_MASK; //开启I2C0时钟
     62          
     63              if(scl_pin == PTD8)
     64              {
     65                PORTD->PCR[8] = PORT_PCR_MUX(2) | ode_mask;         
     66              }
     67              else if(scl_pin == PTB0) 
     68              {
     69                PORTB->PCR[0] = PORT_PCR_MUX(2) | ode_mask;
     70              }
     71              else //scl_pin = PTB2
     72              {
     73                PORTB->PCR[2] = PORT_PCR_MUX(2) | ode_mask;
     74              }
     75          
     76              if(sda_pin == PTD9)
     77              {
     78                PORTD->PCR[9] = PORT_PCR_MUX(2) | ode_mask;
     79              }
     80              else if(sda_pin == PTB1) 
     81              {
     82                PORTB->PCR[1] = PORT_PCR_MUX(2) | ode_mask;
     83              }
     84              else //sda_pin = PTB3
     85              {
     86                PORTB->PCR[3] = PORT_PCR_MUX(2) | ode_mask; 
     87              }
     88            }
     89            else if(i2cx == I2C1)
     90            { 
     91              SIM->SCGC4 |= SIM_SCGC4_I2C1_MASK; //开启I2C1时钟
     92          
     93              if(scl_pin == PTE1)
     94              {
     95                PORTE->PCR[1] = PORT_PCR_MUX(6) | ode_mask;         
     96              }
     97              else //scl_pin = PTC10
     98              {
     99                PORTC->PCR[10] = PORT_PCR_MUX(2) | ode_mask;  
    100              }
    101          
    102              if(sda_pin == PTE0)
    103              {
    104                PORTE->PCR[0] = PORT_PCR_MUX(6) | ode_mask;
    105              }
    106              else //sda_pin = PTC11
    107              {
    108                PORTC->PCR[11] = PORT_PCR_MUX(2) | ode_mask; 
    109              }
    110            }
    111            else
    112              return 0;
    113            
    114            if(i2c_init_structure.I2C_IntEnable == TRUE && isr_func != NULL)
    115            {
    116              //产生I2C中断的中断源：
    117              //1,完成1个字节传输时，IICIF置位产生中断;
    118              //2,当Calling Address匹配成功时产生中断，参考K60文档1456页I2Cx_S寄存器IAAS位;
    119              //3,从机模式下当总线仲裁丢失时，IICIF置位产生中断;
    120              //  需要同时写1清除II2Cx_S的ARBL标志位和 I2Cx_S的 IICIF的标志位;
    121              //4,如果SMB寄存器的SHTF2 interrupt使能，当SHTF2 timeout时IICIF置位产生中断;
    122              //  需要同时写1清除I2Cx_SMB的SLTF标志位和 I2Cx_S的 IICIF的标志位;
    123              //5,当SLT寄存器不为0时，SMBus的SCL low timer计数等于SLT的值时IICIF置位产生中断;
    124              //  需要同时写1清除I2Cx_SMB的SHTF2标志位和 I2Cx_S的 IICIF的标志位;
    125              //6,当Wakeup 使能，I2C在停止模式下接收到Wakeup信号，将产生中断.
    126          
    127              i2cx->C1 |= I2C_C1_IICIE_MASK;
    128          
    129              if(i2cx == I2C0)
    130              {
    131                I2C_ISR[0] = isr_func;
    132              }
    133              else if(i2cx == I2C0)
    134              {
    135                I2C_ISR[1] = isr_func;
    136              }
    137              else 
    138                return 0;
    139            }
    140          
    141            //i2cx->C2 |= I2C_C2_HDRS_MASK;      //提高I2C驱动能力
    142            i2cx->F  = I2C_F_ICR(bus_speed)|I2C_F_MULT(0);   //配置I2Cx SCL BusSpeed
    143            i2cx->C1 |= I2C_C1_IICEN_MASK;      //使能I2Cx
    144            
    145            return 1;
    146          }
    147          
    148          /*
    149           * LPLD_I2C_Deinit
    150           * I2C模块反初始化函数，在该函数中关闭I2Cx的外设总线时钟，关闭I2C模块的
    151           * 时钟，禁止外设中断。
    152           *
    153           * 参数:
    154           *    I2C_InitTypeDef--i2c_init_structure
    155           *                     具体定义见I2C_InitTypeDef
    156           *
    157           * 输出:
    158           *    无
    159           *
    160           */  
    161          uint8 LPLD_I2C_Deinit(I2C_InitTypeDef i2c_init_structure)
    162          {
    163            I2C_Type *i2cx = i2c_init_structure.I2C_I2Cx;
    164          
    165            i2cx->C1 &= ~I2C_C1_IICEN_MASK;      //I2Cx
    166            if(i2cx == I2C0)
    167            {
    168              SIM->SCGC4 &= ~SIM_SCGC4_I2C0_MASK; //关闭I2C0时钟
    169              disable_irq((IRQn_Type)I2C0_IRQn);
    170            }
    171            else if (i2cx == I2C1)
    172            {
    173              SIM->SCGC4 &= ~SIM_SCGC4_I2C1_MASK; //关闭I2C1时钟
    174              disable_irq((IRQn_Type)I2C1_IRQn);
    175            }
    176            else
    177            {
    178              return 0;
    179            }
    180            return 1;
    181          }
    182          
    183          /*
    184           * LPLD_I2C_EnableIrq
    185           * I2C外设中断使能
    186           *
    187           * 参数:
    188           *    I2C_InitTypeDef--i2c_init_structure
    189           *                     具体定义见I2C_InitTypeDef
    190           *
    191           * 输出:
    192           *    无
    193           *
    194           */  
    195          void LPLD_I2C_EnableIrq(I2C_InitTypeDef i2c_init_structure)
    196          {
    197            I2C_Type *i2cx = i2c_init_structure.I2C_I2Cx; 
    198          
    199            if(i2cx == I2C0)
    200            {
    201              enable_irq((IRQn_Type)I2C0_IRQn);
    202            }
    203            else if (i2cx == I2C1)
    204            {
    205              enable_irq((IRQn_Type)I2C1_IRQn);
    206            }
    207            else
    208            {
    209              return;
    210            }
    211          }
    212          
    213          /*
    214           * LPLD_I2C_DisableIrq
    215           * 禁止I2C外设中断
    216           *
    217           * 参数:
    218           *    I2C_InitTypeDef--i2c_init_structure
    219           *                     具体定义见I2C_InitTypeDef
    220           *
    221           * 输出:
    222           *    无
    223           *
    224           */  
    225          void LPLD_I2C_DisableIrq(I2C_InitTypeDef i2c_init_structure)
    226          {
    227            I2C_Type *i2cx = i2c_init_structure.I2C_I2Cx;
    228            i2cx->C1 &= ~I2C_C1_IICIE_MASK;
    229          
    230            if(i2cx == I2C0)
    231            {
    232              disable_irq((IRQn_Type)I2C0_IRQn);
    233            }
    234            else if (i2cx == I2C1)
    235            {
    236              disable_irq((IRQn_Type)I2C1_IRQn);
    237            }
    238            else
    239            {
    240              return;
    241            }
    242          }
    243          
    244          /*
    245           * LPLD_I2C_Start
    246           * 产生I2C开始信号
    247           * 
    248           * 参数:
    249           *    i2cx--选择I2C模块的通道
    250           *      |__I2C0           --I2C通道0
    251           *      |__I2C1           --I2C通道1
    252           * 输出:
    253           *    无
    254           */
    255          void LPLD_I2C_Start(I2C_Type *i2cx)
    256          {
    257            i2cx->C1 |= I2C_C1_TX_MASK ;
    258            i2cx->C1 |= I2C_C1_MST_MASK ;
    259          }
    260          
    261          /*
    262           * LPLD_ReStart
    263           * I2C再次产生开始信号
    264           * 
    265           * 参数:
    266           *    i2cx--选择I2C模块的通道
    267           *      |__I2C0           --I2C通道0
    268           *      |__I2C1           --I2C通道1
    269           * 输出:
    270           *    无
    271          */
    272          void LPLD_I2C_ReStart(I2C_Type *i2cx)
    273          {
    274            i2cx->C1 |= I2C_C1_RSTA_MASK ;
    275          }
    276          
    277          /*
    278           * LPLD_I2C_Stop
    279           * 产生I2C停止信号
    280           * 
    281           * 参数:
    282           *    i2cx--选择I2C模块的通道
    283           *      |__I2C0           --I2C通道0
    284           *      |__I2C1           --I2C通道1
    285           * 输出:
    286           *    无
    287           */
    288          void LPLD_I2C_Stop(I2C_Type *i2cx)
    289          {
    290            i2cx->C1 &=(~I2C_C1_MST_MASK);
    291            i2cx->C1 &=(~I2C_C1_TX_MASK); 
    292          }
    293          
    294          /*
    295           * LPLD_I2C_WaitAck
    296           * I2C设置等待应答信号，开启则等待，关闭则不等待
    297           * 
    298           * 参数:
    299           *    i2cx--选择I2C模块的通道
    300           *      |__I2C0           --I2C通道0
    301           *      |__I2C1           --I2C通道1
    302           *    is_wait--选择是否等待应答
    303           *      |__I2C_ACK_OFF    --关闭等待Ack
    304           *      |__I2C_ACK_ON     --开启等待Ack，并等待ACK信号
    305           * 输出:
    306           *    无
    307           */
    308          void LPLD_I2C_WaitAck(I2C_Type *i2cx, uint8 is_wait)
    309          {
    310            if( mycar.mpu6050_error==1)
    311            {
    312            }
    313            else 
    314            {
    315              uint16 time_out;
    316              if(is_wait == I2C_ACK_ON)
    317              {
    318                while(!(i2cx->S & I2C_S_IICIF_MASK))
    319                {
    320                  if(time_out>60000) //如果等待超时，强行退出
    321                  {
    322                    printf("6050 error\n");
    323                    if(mycar.status>0)
    324                    {
    325                      mycar.mpu6050_error = 1;
    326                    }
    327                    break;
    328                  }
    329                  else time_out++;
    330                }
    331                i2cx->S |= I2C_S_IICIF_MASK;
    332              }
    333              else
    334              {
    335                //关闭I2C的ACK
    336                i2cx->C1 |= I2C_C1_TXAK_MASK; 
    337              }
    338            }
    339          }
    340          
    341          /*
    342           * LPLD_I2C_Write
    343           * I2C发送一个字节给目的地址设备
    344           * 
    345           * 参数:
    346           *    i2cx--选择I2C模块的通道
    347           *      |__I2C0           --I2C通道0
    348           *      |__I2C1           --I2C通道1
    349           *    data8--要发送的字节数据
    350           * 输出:
    351           *    无
    352           *
    353           */
    354          void LPLD_I2C_WriteByte(I2C_Type *i2cx, uint8 data8)
    355          {
    356            i2cx->D = data8; 
    357          }
    358          
    359          /*
    360           * LPLD_I2C_Read
    361           * I2C从外部设备读一个字节
    362           * 
    363           * 参数:
    364           *    i2cx--选择I2C模块的通道
    365           *      |__I2C0           --I2C通道0
    366           *      |__I2C1           --I2C通道1
    367           * 输出:
    368           *    I2C读取的字节 
    369           */
    370          
    371          uint8 LPLD_I2C_ReadByte(I2C_Type *i2cx)
    372          {
    373            uint8 temp;
    374            temp = i2cx->D; 
    375            return temp;
    376          }
    377          
    378          /*
    379           * LPLD_I2C_SetMasterWR
    380           * I2C主机读写模式配置
    381           * 
    382           * 参数:
    383           *    IICx--选择I2C模块的通道
    384           *      |__I2C0           --I2C通道0
    385           *      |__I2C1           --I2C通道1
    386           *    mode--读写模式选择
    387           *      |__I2C_MWSR         --主机写
    388           *      |__I2C_MRSW         --主机读
    389           * 输出:
    390           *    无
    391           */
    392          void LPLD_I2C_SetMasterWR(I2C_Type *i2cx, uint8 mode)
    393          {
    394            if(mode==I2C_MRSW) 
    395              i2cx->C1 &= (~I2C_C1_TX_MASK);
    396            else
    397              i2cx->C1 |= ( I2C_C1_TX_MASK);
    398          }
    399          
    400          /*
    401           * LPLD_I2C_StartTrans
    402           * I2C开始传输函数，需要设置外围设备地址和读写模式
    403           * 
    404           * 参数:
    405           *    IICx--选择I2C模块的通道
    406           *      |__I2C0           --I2C通道0
    407           *      |__I2C1           --I2C通道1
    408           *    addr--外围设备地址     
    409           *    mode--读写模式选择
    410           *      |__I2C_MWSR         --主机写
    411           *      |__I2C_MRSW         --主机读
    412           * 输出:
    413           *    无
    414           */
    415          void LPLD_I2C_StartTrans(I2C_Type *i2cx, uint8 addr, uint8 mode)
    416          {
    417            //I2C产生start信号
    418            LPLD_I2C_Start(i2cx);
    419            //将从机地址和主机读写位合成一个字节写入
    420            LPLD_I2C_WriteByte(i2cx, (addr<<1)|mode );
    421          }
    422          
    423          //HW层中断函数，用户无需调用
    424          void I2C0_IRQHandler(void)
    425          {
    426          #if (UCOS_II > 0u)
    427            OS_CPU_SR  cpu_sr = 0u;
    428            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    429            OSIntEnter();
    430            OS_EXIT_CRITICAL();
    431          #endif
    432            if(I2C0->S & I2C_S_IICIF_MASK)
    433            {
    434              I2C_ISR[0]();
    435              if(I2C0->SMB & I2C_SMB_SLTF_MASK)
    436              {
    437                I2C0->SMB |= I2C_SMB_SLTF_MASK;
    438              }
    439              if(I2C0->SMB & I2C_SMB_SHTF2_MASK)
    440              {
    441                I2C0->SMB |= I2C_SMB_SHTF2_MASK;
    442              }
    443              if(I2C0->S & I2C_S_ARBL_MASK)
    444              {
    445                I2C0->S |= I2C_S_ARBL_MASK;
    446              }
    447              I2C0->S |= I2C_S_IICIF_MASK;
    448            }
    449          #if (UCOS_II > 0u)
    450            OSIntExit();          //告知系统此时即将离开中断服务子函数
    451          #endif
    452          }
    453          //HW层中断函数，用户无需调用
    454          void I2C1_IRQHandler(void)
    455          {
    456          
    457          #if (UCOS_II > 0u)
    458            OS_CPU_SR  cpu_sr = 0u;
    459            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    460            OSIntEnter();
    461            OS_EXIT_CRITICAL();
    462          #endif
    463          
    464            if(I2C1->S & I2C_S_IICIF_MASK)
    465            {
    466              I2C_ISR[1]();
    467              if(I2C1->SMB & I2C_SMB_SLTF_MASK)
    468              {
    469                I2C1->SMB |= I2C_SMB_SLTF_MASK;
    470              }
    471              if(I2C1->SMB & I2C_SMB_SHTF2_MASK)
    472              {
    473                I2C1->SMB |= I2C_SMB_SHTF2_MASK;
    474              }
    475              if(I2C1->S & I2C_S_ARBL_MASK)
    476              {
    477                I2C1->S |= I2C_S_ARBL_MASK;
    478              }
    479              I2C1->S |= I2C_S_IICIF_MASK;
    480            }
    481            
    482          #if (UCOS_II > 0u)
    483            OSIntExit();          //告知系统此时即将离开中断服务子函数
    484          #endif
    485          }
    486          
    487          
    488          

Errors: 1
Warnings: none
