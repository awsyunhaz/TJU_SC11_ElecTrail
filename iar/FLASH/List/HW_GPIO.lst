###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        06/Jul/2016  19:37:44
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\lib\LPLD\HW\HW_GPIO.c
#    Command line =  
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\lib\LPLD\HW\HW_GPIO.c
#        -D LPLD_K60 -lCN
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail_A车\iar\FLASH\List\
#        -lB
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail_A车\iar\FLASH\List\
#        -o
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail_A车\iar\FLASH\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M4 -e --fpu=None --dlib_config "D:\IAR Systems\Embedded
#        Workbench 7.0\arm\INC\c\DLib_Config_Full.h" -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail_A车\iar\..\app\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail_A车\iar\..\..\..\lib\CPU\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail_A车\iar\..\..\..\lib\common\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail_A车\iar\..\..\..\lib\LPLD\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail_A车\iar\..\..\..\lib\LPLD\HW\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail_A车\iar\..\..\..\lib\LPLD\DEV\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail_A车\iar\..\..\..\lib\uCOS-II\Ports\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail_A车\iar\..\..\..\lib\uCOS-II\Source\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail_A车\iar\..\..\..\lib\FatFs\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail_A车\iar\..\..\..\lib\FatFs\option\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail_A车\iar\..\..\..\lib\USB\common\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail_A车\iar\..\..\..\lib\USB\driver\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail_A车\iar\..\..\..\lib\USB\descriptor\
#        -I
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail_A车\iar\..\..\..\lib\USB\class\
#        -Ol -I "D:\IAR Systems\Embedded Workbench 7.0\arm\CMSIS\Include\" -D
#        ARM_MATH_CM4
#    List file    =  
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail_A车\iar\FLASH\List\HW_GPIO.lst
#    Object file  =  
#        C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\project\TJU_SC11_ElecTrail_A车\iar\FLASH\Obj\HW_GPIO.o
#
###############################################################################

C:\Users\zyh\Desktop\飞思卡尔\软件组作业一（2015.11.23）\拉普兰德例程及OLED测试程序\lib\LPLD\HW\HW_GPIO.c
      1          /**
      2          * @file HW_GPIO.c
      3          * @version 3.03[By LPLD]
      4          * @date 2014-2-10
      5          * @brief GPIO底层模块相关函数
      6          *
      7          * 更改建议:不建议修改
      8          *
      9          * 版权所有:北京拉普兰德电子技术有限公司
     10          * http://www.lpld.cn
     11          * mail:support@lpld.cn
     12          *
     13          * @par
     14          * 本代码由拉普兰德[LPLD]开发并维护，并向所有使用者开放源代码。
     15          * 开发者可以随意修使用或改源代码。但本段及以上注释应予以保留。
     16          * 不得更改或删除原版权所有者姓名，二次开发者可以加注二次版权所有者。
     17          * 但应在遵守此协议的基础上，开放源代码、不得出售代码本身。
     18          * 拉普兰德不负责由于使用本代码所带来的任何事故、法律责任或相关不良影响。
     19          * 拉普兰德无义务解释、说明本代码的具体原理、功能、实现方法。
     20          * 除非拉普兰德[LPLD]授权，开发者不得将本代码用于商业产品。
     21          */
     22          #include "common.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable9  ;; 0xe000e100
   \   0000000A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000C   0x0940             LSRS     R0,R0,#+5
   \   0000000E   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable9_1  ;; 0xe000e180
   \   0000000A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000C   0x0940             LSRS     R0,R0,#+5
   \   0000000E   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return
     23          #include "HW_GPIO.h"
     24          
     25          
     26          //用户自定义中断服务函数数组

   \                                 In section .bss, align 4
     27          GPIO_ISR_CALLBACK GPIO_ISR[5];
   \                     GPIO_ISR:
   \   00000000                      DS8 20
     28          
     29          /*
     30           * 定义数组
     31           */

   \                                 In section .data, align 4
     32          GPIO_MemMapPtr GPIOX[5] = {PTA_BASE_PTR, PTB_BASE_PTR, PTC_BASE_PTR, PTD_BASE_PTR, PTE_BASE_PTR}; //定义五个指针数组保存 GPIOX 的地址
   \                     GPIOX:
   \   00000000   0x400FF000         DC32 400FF000H, 400FF040H, 400FF080H, 400FF0C0H, 400FF100H
   \              0x400FF040   
   \              0x400FF080   
   \              0x400FF0C0   
   \              0x400FF100   
     33          
     34          /*
     35          * LPLD_GPIO_Init
     36          * GPIO通用初始化函数
     37          * 
     38          * 参数:
     39          *    gpio_init_structure--GPIO初始化结构体，
     40          *                        具体定义见GPIO_InitTypeDef
     41          *
     42          * 输出:
     43          *    0--配置错误
     44          *    1--配置成功
     45          */

   \                                 In section .text, align 2, keep-with-next
     46          uint8 LPLD_GPIO_Init(GPIO_InitTypeDef gpio_init_structure)
     47          {
   \                     LPLD_GPIO_Init: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB4F0             PUSH     {R4-R7}
     48            uint8 i;
     49            PORT_Type *portx;
     50            uint32 pcr = PORT_PCR_MUX(1)| gpio_init_structure.GPIO_PinControl; 
   \   00000004   0x9806             LDR      R0,[SP, #+24]
   \   00000006   0xF450 0x7080      ORRS     R0,R0,#0x100
     51            GPIO_Type *ptx = gpio_init_structure.GPIO_PTx;
   \   0000000A   0x9B04             LDR      R3,[SP, #+16]
     52            uint32 pins = gpio_init_structure.GPIO_Pins;
   \   0000000C   0x9905             LDR      R1,[SP, #+20]
     53            uint8 dir = gpio_init_structure.GPIO_Dir;
   \   0000000E   0xF89D 0x701C      LDRB     R7,[SP, #+28]
     54            uint8 output = gpio_init_structure.GPIO_Output;
   \   00000012   0xF89D 0x401D      LDRB     R4,[SP, #+29]
     55            GPIO_ISR_CALLBACK isr_func = gpio_init_structure.GPIO_Isr;
   \   00000016   0x9A08             LDR      R2,[SP, #+32]
     56            
     57            //参数检查
     58            ASSERT( ptx <= PTE);                  //判断端口
     59            ASSERT( dir <= 1 );                   //判断方向
     60            ASSERT( output <= 1 );                //判断输出电平状态
     61            
     62            if(ptx == PTA)
   \   00000018   0x....             LDR.N    R5,??DataTable9_2  ;; 0x400ff000
   \   0000001A   0x42AB             CMP      R3,R5
   \   0000001C   0xD10C             BNE.N    ??LPLD_GPIO_Init_0
     63            {
     64              portx = PORTA;  
   \   0000001E   0x....             LDR.N    R6,??DataTable9_3  ;; 0x40049000
     65              i = 0;
   \   00000020   0x2500             MOVS     R5,#+0
     66            }
     67            else if(ptx == PTB) 
     68            {
     69              portx = PORTB;
     70              i = 1;
     71            }
     72            else if(ptx == PTC) 
     73            {
     74              portx = PORTC;
     75              i = 2;
     76            }
     77            else if(ptx == PTD) 
     78            {
     79              portx = PORTD;
     80              i = 3; 
     81            }
     82            else if(ptx == PTE) 
     83            {
     84              portx = PORTE;
     85              i = 4;
     86            }
     87            else
     88              return 0;
     89            
     90            //输入或输出设置
     91            if(dir==DIR_OUTPUT)
   \                     ??LPLD_GPIO_Init_1: (+1)
   \   00000022   0xB2FF             UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
   \   00000024   0x2F01             CMP      R7,#+1
   \   00000026   0xD123             BNE.N    ??LPLD_GPIO_Init_2
     92            {
     93              ptx->PDDR |= pins;
   \   00000028   0x695F             LDR      R7,[R3, #+20]
   \   0000002A   0x430F             ORRS     R7,R1,R7
   \   0000002C   0x615F             STR      R7,[R3, #+20]
     94              //设置初始输出
     95              if(output==OUTPUT_H)
   \   0000002E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000030   0x2C01             CMP      R4,#+1
   \   00000032   0xD11B             BNE.N    ??LPLD_GPIO_Init_3
     96              {
     97                ptx->PSOR = pins; 
   \   00000034   0x6059             STR      R1,[R3, #+4]
   \   00000036   0xE01E             B.N      ??LPLD_GPIO_Init_4
     98              }
   \                     ??LPLD_GPIO_Init_0: (+1)
   \   00000038   0x....             LDR.N    R5,??DataTable9_4  ;; 0x400ff040
   \   0000003A   0x42AB             CMP      R3,R5
   \   0000003C   0xD102             BNE.N    ??LPLD_GPIO_Init_5
   \   0000003E   0x....             LDR.N    R6,??DataTable9_5  ;; 0x4004a000
   \   00000040   0x2501             MOVS     R5,#+1
   \   00000042   0xE7EE             B.N      ??LPLD_GPIO_Init_1
   \                     ??LPLD_GPIO_Init_5: (+1)
   \   00000044   0x....             LDR.N    R5,??DataTable9_6  ;; 0x400ff080
   \   00000046   0x42AB             CMP      R3,R5
   \   00000048   0xD102             BNE.N    ??LPLD_GPIO_Init_6
   \   0000004A   0x....             LDR.N    R6,??DataTable9_7  ;; 0x4004b000
   \   0000004C   0x2502             MOVS     R5,#+2
   \   0000004E   0xE7E8             B.N      ??LPLD_GPIO_Init_1
   \                     ??LPLD_GPIO_Init_6: (+1)
   \   00000050   0x....             LDR.N    R5,??DataTable9_8  ;; 0x400ff0c0
   \   00000052   0x42AB             CMP      R3,R5
   \   00000054   0xD102             BNE.N    ??LPLD_GPIO_Init_7
   \   00000056   0x....             LDR.N    R6,??DataTable9_9  ;; 0x4004c000
   \   00000058   0x2503             MOVS     R5,#+3
   \   0000005A   0xE7E2             B.N      ??LPLD_GPIO_Init_1
   \                     ??LPLD_GPIO_Init_7: (+1)
   \   0000005C   0x....             LDR.N    R5,??DataTable9_10  ;; 0x400ff100
   \   0000005E   0x42AB             CMP      R3,R5
   \   00000060   0xD102             BNE.N    ??LPLD_GPIO_Init_8
   \   00000062   0x....             LDR.N    R6,??DataTable9_11  ;; 0x4004d000
   \   00000064   0x2504             MOVS     R5,#+4
   \   00000066   0xE7DC             B.N      ??LPLD_GPIO_Init_1
   \                     ??LPLD_GPIO_Init_8: (+1)
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0xE019             B.N      ??LPLD_GPIO_Init_9
     99              else
    100              {
    101                ptx->PCOR = pins;
   \                     ??LPLD_GPIO_Init_3: (+1)
   \   0000006C   0x6099             STR      R1,[R3, #+8]
   \   0000006E   0xE002             B.N      ??LPLD_GPIO_Init_4
    102              }
    103            }
    104            else
    105            { 
    106              ptx->PDDR &= ~(pins);
   \                     ??LPLD_GPIO_Init_2: (+1)
   \   00000070   0x695C             LDR      R4,[R3, #+20]
   \   00000072   0x438C             BICS     R4,R4,R1
   \   00000074   0x615C             STR      R4,[R3, #+20]
    107            }
    108            
    109            //配置所选引脚的控制寄存器
    110            for(uint8 i=0; i<32; i++)
   \                     ??LPLD_GPIO_Init_4: (+1)
   \   00000076   0x2300             MOVS     R3,#+0
   \   00000078   0xE007             B.N      ??LPLD_GPIO_Init_10
    111            {
    112              if(pins&(1ul<<i))
   \                     ??LPLD_GPIO_Init_11: (+1)
   \   0000007A   0xFA31 0xF403      LSRS     R4,R1,R3
   \   0000007E   0x07E4             LSLS     R4,R4,#+31
   \   00000080   0xD502             BPL.N    ??LPLD_GPIO_Init_12
    113              {
    114                portx->PCR[i] = pcr;
   \   00000082   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000084   0xF846 0x0023      STR      R0,[R6, R3, LSL #+2]
    115              }
    116            }
   \                     ??LPLD_GPIO_Init_12: (+1)
   \   00000088   0x1C5B             ADDS     R3,R3,#+1
   \                     ??LPLD_GPIO_Init_10: (+1)
   \   0000008A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000008C   0x2B20             CMP      R3,#+32
   \   0000008E   0xDBF4             BLT.N    ??LPLD_GPIO_Init_11
    117            
    118            if(isr_func!=NULL)
   \   00000090   0x0010             MOVS     R0,R2
   \   00000092   0x2800             CMP      R0,#+0
   \   00000094   0xD003             BEQ.N    ??LPLD_GPIO_Init_13
    119              GPIO_ISR[i] = isr_func;
   \   00000096   0x....             LDR.N    R0,??DataTable9_12
   \   00000098   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000009A   0xF840 0x2025      STR      R2,[R0, R5, LSL #+2]
    120            
    121            return 1;
   \                     ??LPLD_GPIO_Init_13: (+1)
   \   0000009E   0x2001             MOVS     R0,#+1
   \                     ??LPLD_GPIO_Init_9: (+1)
   \   000000A0   0xBCF0             POP      {R4-R7}
   \   000000A2   0xB004             ADD      SP,SP,#+16
   \   000000A4   0x4770             BX       LR               ;; return
    122          }
    123          /*
    124          * GPIO
    125          * 简易初始化GPIO
    126          * 参数:
    127          *    ptxn--端口号枚举
    128          *      |__PTA0~PTE31 
    129          *    dir--端口方向
    130          *      |__0--输入
    131          *      |__1--输出
    132          *
    133          * 输出:无
    134          *
    135          */

   \                                 In section .text, align 2, keep-with-next
    136          void GPIO(PortPinsEnum_Type ptxn,uint8 dir)
    137          {
   \                     GPIO: (+1)
   \   00000000   0xB410             PUSH     {R4}
    138            uint8 x = ptxn >> 5;
   \   00000002   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000004   0x0942             LSRS     R2,R0,#+5
    139            uint8 i = ptxn & 0x1F;
   \   00000006   0xF010 0x001F      ANDS     R0,R0,#0x1F
    140            
    141            GPIO_Type *ptx = (GPIO_Type*)(PTA_BASE+(x<<6));
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0x0193             LSLS     R3,R2,#+6
   \   0000000E   0xF103 0x4380      ADD      R3,R3,#+1073741824
   \   00000012   0xF513 0x237F      ADDS     R3,R3,#+1044480
    142            PORT_Type *portx = (PORT_Type*)(PORTA_BASE+(x<<12));
   \   00000016   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000018   0x0312             LSLS     R2,R2,#+12
   \   0000001A   0xF102 0x4280      ADD      R2,R2,#+1073741824
   \   0000001E   0xF512 0x2292      ADDS     R2,R2,#+299008
    143            
    144            DDR(ptx,i)=dir;
   \   00000022   0x3314             ADDS     R3,R3,#+20
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x0084             LSLS     R4,R0,#+2
   \   00000028   0xEB14 0x1343      ADDS     R3,R4,R3, LSL #+5
   \   0000002C   0xF113 0x4384      ADDS     R3,R3,#+1107296256
   \   00000030   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000032   0x6019             STR      R1,[R3, #+0]
    145            portx->PCR[i] = PORT_PCR_MUX(1);
   \   00000034   0xF44F 0x7180      MOV      R1,#+256
   \   00000038   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003A   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    146          }
   \   0000003E   0xBC10             POP      {R4}
   \   00000040   0x4770             BX       LR               ;; return
    147          /*
    148          * LPLD_GPIO_EnableIrq
    149          * 使能GPIO外部中断
    150          * 
    151          * 参数:
    152          *    gpio_init_structure--GPIO初始化结构体，
    153          *                        具体定义见GPIO_InitTypeDef
    154          *
    155          * 输出:
    156          *    0--配置错误
    157          *    1--配置成功
    158          *
    159          */

   \                                 In section .text, align 2, keep-with-next
    160          uint8 LPLD_GPIO_EnableIrq(GPIO_InitTypeDef gpio_init_structure)
    161          {
   \                     LPLD_GPIO_EnableIrq: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB580             PUSH     {R7,LR}
    162            uint8 i;
    163            GPIO_Type *ptx = gpio_init_structure.GPIO_PTx;
   \   00000004   0x9802             LDR      R0,[SP, #+8]
    164            
    165            //参数检查
    166            ASSERT( ptx <= PTE);                  //判断端口
    167            
    168            if(ptx == PTA)
   \   00000006   0x....             LDR.N    R1,??DataTable9_2  ;; 0x400ff000
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD101             BNE.N    ??LPLD_GPIO_EnableIrq_0
    169              i = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE00F             B.N      ??LPLD_GPIO_EnableIrq_1
    170            else if(ptx == PTB) 
   \                     ??LPLD_GPIO_EnableIrq_0: (+1)
   \   00000010   0x....             LDR.N    R1,??DataTable9_4  ;; 0x400ff040
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD101             BNE.N    ??LPLD_GPIO_EnableIrq_2
    171              i = 1;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE00A             B.N      ??LPLD_GPIO_EnableIrq_1
    172            else if(ptx == PTC) 
   \                     ??LPLD_GPIO_EnableIrq_2: (+1)
   \   0000001A   0x....             LDR.N    R1,??DataTable9_6  ;; 0x400ff080
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD101             BNE.N    ??LPLD_GPIO_EnableIrq_3
    173              i = 2;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xE005             B.N      ??LPLD_GPIO_EnableIrq_1
    174            else if(ptx == PTD) 
   \                     ??LPLD_GPIO_EnableIrq_3: (+1)
   \   00000024   0x....             LDR.N    R1,??DataTable9_8  ;; 0x400ff0c0
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD101             BNE.N    ??LPLD_GPIO_EnableIrq_4
    175              i = 3;
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0xE000             B.N      ??LPLD_GPIO_EnableIrq_1
    176            else
    177              i = 4;
   \                     ??LPLD_GPIO_EnableIrq_4: (+1)
   \   0000002E   0x2004             MOVS     R0,#+4
    178            
    179            enable_irq((IRQn_Type)(i + PORTA_IRQn));
   \                     ??LPLD_GPIO_EnableIrq_1: (+1)
   \   00000030   0x3057             ADDS     R0,R0,#+87
   \   00000032   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000034   0x.... 0x....      BL       NVIC_EnableIRQ
    180            
    181            return 1;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xBC02             POP      {R1}
   \   0000003C   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    182          }
    183          
    184          /*
    185          * LPLD_GPIO_DisableIrq
    186          * 禁用GPIO外部中断
    187          * 
    188          * 参数:
    189          *    gpio_init_structure--GPIO初始化结构体，
    190          *                        具体定义见GPIO_InitTypeDef
    191          *
    192          * 输出:
    193          *    0--配置错误
    194          *    1--配置成功
    195          *
    196          */

   \                                 In section .text, align 2, keep-with-next
    197          uint8 LPLD_GPIO_DisableIrq(GPIO_InitTypeDef gpio_init_structure)
    198          {
   \                     LPLD_GPIO_DisableIrq: (+1)
   \   00000000   0xB40F             PUSH     {R0-R3}
   \   00000002   0xB580             PUSH     {R7,LR}
    199            uint8 i;
    200            GPIO_Type *ptx = gpio_init_structure.GPIO_PTx;
   \   00000004   0x9802             LDR      R0,[SP, #+8]
    201            
    202            //参数检查
    203            ASSERT( ptx <= PTE);                  //判断端口
    204            
    205            if(ptx == PTA)
   \   00000006   0x....             LDR.N    R1,??DataTable9_2  ;; 0x400ff000
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD101             BNE.N    ??LPLD_GPIO_DisableIrq_0
    206              i = 0;
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xE00F             B.N      ??LPLD_GPIO_DisableIrq_1
    207            else if(ptx == PTB) 
   \                     ??LPLD_GPIO_DisableIrq_0: (+1)
   \   00000010   0x....             LDR.N    R1,??DataTable9_4  ;; 0x400ff040
   \   00000012   0x4288             CMP      R0,R1
   \   00000014   0xD101             BNE.N    ??LPLD_GPIO_DisableIrq_2
    208              i = 1;
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xE00A             B.N      ??LPLD_GPIO_DisableIrq_1
    209            else if(ptx == PTC) 
   \                     ??LPLD_GPIO_DisableIrq_2: (+1)
   \   0000001A   0x....             LDR.N    R1,??DataTable9_6  ;; 0x400ff080
   \   0000001C   0x4288             CMP      R0,R1
   \   0000001E   0xD101             BNE.N    ??LPLD_GPIO_DisableIrq_3
    210              i = 2;
   \   00000020   0x2002             MOVS     R0,#+2
   \   00000022   0xE005             B.N      ??LPLD_GPIO_DisableIrq_1
    211            else if(ptx == PTD) 
   \                     ??LPLD_GPIO_DisableIrq_3: (+1)
   \   00000024   0x....             LDR.N    R1,??DataTable9_8  ;; 0x400ff0c0
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD101             BNE.N    ??LPLD_GPIO_DisableIrq_4
    212              i = 3;
   \   0000002A   0x2003             MOVS     R0,#+3
   \   0000002C   0xE000             B.N      ??LPLD_GPIO_DisableIrq_1
    213            else
    214              i = 4;
   \                     ??LPLD_GPIO_DisableIrq_4: (+1)
   \   0000002E   0x2004             MOVS     R0,#+4
    215            
    216            disable_irq((IRQn_Type)(i + PORTA_IRQn));
   \                     ??LPLD_GPIO_DisableIrq_1: (+1)
   \   00000030   0x3057             ADDS     R0,R0,#+87
   \   00000032   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000034   0x.... 0x....      BL       NVIC_DisableIRQ
    217            
    218            return 1;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0xBC02             POP      {R1}
   \   0000003C   0xF85D 0xFB14      LDR      PC,[SP], #+20    ;; return
    219          }
    220          
    221          /*
    222          * LPLD_GPIO_Ouptut
    223          * 设置GPIO端口0~31位的输出
    224          * 
    225          * 参数:
    226          *    ptx--端口号
    227          *      |__PTA        --Port A
    228          *      |__PTB        --Port B
    229          *      |__PTC        --Port C
    230          *      |__PTD        --Port D
    231          *      |__PTE        --Port E
    232          *    data32--输出数据
    233          *      |__0x00000000~0xFFFFFFFF--低到高代表GPIO口的第0~31位数据
    234          *
    235          * 输出:
    236          *
    237          */

   \                                 In section .text, align 2, keep-with-next
    238          __INLINE void LPLD_GPIO_Output(GPIO_Type *ptx, uint32 data32)
    239          { 
    240            ptx->PDOR = data32;
   \                     LPLD_GPIO_Output: (+1)
   \   00000000   0x6001             STR      R1,[R0, #+0]
    241          }
   \   00000002   0x4770             BX       LR               ;; return
    242          
    243          /*
    244          * LPLD_GPIO_Ouptut_b
    245          * 设置GPIO端口一位的输出
    246          * 
    247          * 参数:
    248          *    ptx--端口号
    249          *      |__PTA        --Port A
    250          *      |__PTB        --Port B
    251          *      |__PTC        --Port C
    252          *      |__PTD        --Port D
    253          *      |__PTE        --Port E
    254          *    lsb_num--端口引脚位数编号
    255          *      |__0~31       --GPIO口的第0~31位
    256          *    data1--输出数据
    257          *      |__0          --输出低电平
    258          *      |__1          --输出高电平
    259          *
    260          * 输出:
    261          *
    262          */

   \                                 In section .text, align 2, keep-with-next
    263          __INLINE void LPLD_GPIO_Output_b(GPIO_Type *ptx, uint32 lsb_num, uint8 data1)
    264          {
   \                     LPLD_GPIO_Output_b: (+1)
   \   00000000   0xB410             PUSH     {R4}
    265            ptx->PDOR = (ptx->PDOR & ~(0x01L<<lsb_num)) | (uint32)data1<<lsb_num;
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x2401             MOVS     R4,#+1
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000010   0x4319             ORRS     R1,R1,R3
   \   00000012   0x6001             STR      R1,[R0, #+0]
    266          }
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return
    267          
    268          /*
    269          * LPLD_GPIO_Ouptut_8b
    270          * 设置GPIO端口8位的输出
    271          * 
    272          * 参数:
    273          *    ptx--端口号
    274          *      |__PTA        --Port A
    275          *      |__PTB        --Port B
    276          *      |__PTC        --Port C
    277          *      |__PTD        --Port D
    278          *      |__PTE        --Port E
    279          *    lsb_num--代表8个端口引脚的最低位数编号
    280          *      |__0~24       --GPIO口的第0~24位
    281          *    data8--输出数据
    282          *      |__0x00~0xFF--代表GPIO口输出的8位数据
    283          *
    284          * 输出:
    285          *
    286          */

   \                                 In section .text, align 2, keep-with-next
    287          __INLINE void LPLD_GPIO_Output_8b(GPIO_Type *ptx, uint8 lsb_num, uint8 data8)
    288          {
   \                     LPLD_GPIO_Output_8b: (+1)
   \   00000000   0xB410             PUSH     {R4}
    289            ptx->PDOR = (ptx->PDOR & ~(0xFFL<<lsb_num)) | (uint32)data8<<lsb_num;
   \   00000002   0x6803             LDR      R3,[R0, #+0]
   \   00000004   0x24FF             MOVS     R4,#+255
   \   00000006   0x408C             LSLS     R4,R4,R1
   \   00000008   0x43A3             BICS     R3,R3,R4
   \   0000000A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000C   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000010   0x4319             ORRS     R1,R1,R3
   \   00000012   0x6001             STR      R1,[R0, #+0]
    290          }
   \   00000014   0xBC10             POP      {R4}
   \   00000016   0x4770             BX       LR               ;; return
    291          
    292          /*
    293          * LPLD_GPIO_Toggle
    294          * 设置GPIO端口0~31的电平翻转
    295          * 
    296          * 参数:
    297          *    ptx--端口号
    298          *      |__PTA        --Port A
    299          *      |__PTB        --Port B
    300          *      |__PTC        --Port C
    301          *      |__PTD        --Port D
    302          *      |__PTE        --Port E
    303          *    data32--翻转数据
    304          *      |__0x00000000~0xFFFFFFFF--低到高代表GPIO口的第0~31位的翻转，1为反转，0为保持不变。
    305          *
    306          * 输出:
    307          *
    308          */

   \                                 In section .text, align 2, keep-with-next
    309          __INLINE void LPLD_GPIO_Toggle(GPIO_Type *ptx, uint32 data32)
    310          {  
    311            ptx->PTOR = data32;
   \                     LPLD_GPIO_Toggle: (+1)
   \   00000000   0x60C1             STR      R1,[R0, #+12]
    312          }
   \   00000002   0x4770             BX       LR               ;; return
    313          
    314          /*
    315          * LPLD_GPIO_Toggle_b
    316          * 设置GPIO端口一位的翻转
    317          * 
    318          * 参数:
    319          *    ptx--端口号
    320          *      |__PTA        --Port A
    321          *      |__PTB        --Port B
    322          *      |__PTC        --Port C
    323          *      |__PTD        --Port D
    324          *      |__PTE        --Port E
    325          *    lsb_num--端口引脚位数编号
    326          *      |__0~31       --GPIO口的第0~31位
    327          *
    328          * 输出:
    329          *
    330          */

   \                                 In section .text, align 2, keep-with-next
    331          __INLINE void LPLD_GPIO_Toggle_b(GPIO_Type *ptx, uint8 lsb_num)
    332          {  
    333            ptx->PTOR = 0x01L<<lsb_num;
   \                     LPLD_GPIO_Toggle_b: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000006   0x60C1             STR      R1,[R0, #+12]
    334          }
   \   00000008   0x4770             BX       LR               ;; return
    335          
    336          /*
    337          * LPLD_GPIO_Toggle_8b
    338          * 设置GPIO端口8位的翻转
    339          * 
    340          * 参数:
    341          *    ptx--端口号
    342          *      |__PTA        --Port A
    343          *      |__PTB        --Port B
    344          *      |__PTC        --Port C
    345          *      |__PTD        --Port D
    346          *      |__PTE        --Port E
    347          *    lsb_num--代表8个端口引脚的最低位数编号
    348          *      |__0~24       --GPIO口的第0~24位
    349          *    data8--输出数据
    350          *      |__0x00~0xFF--代表GPIO口输出的8位数据
    351          *
    352          * 输出:
    353          *
    354          */

   \                                 In section .text, align 2, keep-with-next
    355          __INLINE void LPLD_GPIO_Toggle_8b(GPIO_Type *ptx, uint8 lsb_num, uint8 data8)
    356          {
    357            ptx->PTOR = (uint32)data8<<lsb_num;
   \                     LPLD_GPIO_Toggle_8b: (+1)
   \   00000000   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000002   0xFA12 0xF101      LSLS     R1,R2,R1
   \   00000006   0x60C1             STR      R1,[R0, #+12]
    358          }
   \   00000008   0x4770             BX       LR               ;; return
    359          
    360          /*
    361          * LPLD_GPIO_Input
    362          * 取得GPIO口0~31位的数据
    363          * 
    364          * 参数:
    365          *    ptx--端口号
    366          *      |__PTA        --Port A
    367          *      |__PTB        --Port B
    368          *      |__PTC        --Port C
    369          *      |__PTD        --Port D
    370          *      |__PTE        --Port E
    371          *
    372          * 输出:
    373          *    指定GPIO口的32位输入
    374          *
    375          */

   \                                 In section .text, align 2, keep-with-next
    376          __INLINE uint32 LPLD_GPIO_Input(GPIO_Type *ptx)
    377          {
    378            return ptx->PDIR;
   \                     LPLD_GPIO_Input: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x4770             BX       LR               ;; return
    379          }
    380          
    381          /*
    382          * LPLD_GPIO_Input_b
    383          * 取得GPIO口某一位的数据
    384          * 
    385          * 参数:
    386          *    ptx--端口号
    387          *      |__PTA        --Port A
    388          *      |__PTB        --Port B
    389          *      |__PTC        --Port C
    390          *      |__PTD        --Port D
    391          *      |__PTE        --Port E
    392          *    lsb_num--端口引脚位数编号
    393          *      |__0~31       --GPIO口的第0~31位
    394          *
    395          * 输出:
    396          *    指定GPIO口的指定位数的电平
    397          *
    398          */

   \                                 In section .text, align 2, keep-with-next
    399          __INLINE uint8 LPLD_GPIO_Input_b(GPIO_Type *ptx, uint8 lsb_num)
    400          {  
    401            return (uint8)((ptx->PDIR>>lsb_num)&0x01L);
   \                     LPLD_GPIO_Input_b: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x40C8             LSRS     R0,R0,R1
   \   00000004   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   00000008   0x4770             BX       LR               ;; return
    402          }
    403          
    404          /*
    405          * LPLD_GPIO_Input_8b
    406          * 取得GPIO端口8位数据的输入
    407          * 
    408          * 参数:
    409          *    ptx--端口号
    410          *      |__PTA        --Port A
    411          *      |__PTB        --Port B
    412          *      |__PTC        --Port C
    413          *      |__PTD        --Port D
    414          *      |__PTE        --Port E
    415          *    lsb_num--代表8个端口引脚的最低位数编号
    416          *      |__0~24       --GPIO口的第0~24位
    417          *
    418          * 输出:
    419          *    指定GPIO口的8位数据的电平
    420          *
    421          */

   \                                 In section .text, align 2, keep-with-next
    422          __INLINE uint8 LPLD_GPIO_Input_8b(GPIO_Type *ptx, uint8 lsb_num)
    423          {
    424            return (uint8)((ptx->PDIR>>lsb_num)&0xFFL);
   \                     LPLD_GPIO_Input_8b: (+1)
   \   00000000   0x6900             LDR      R0,[R0, #+16]
   \   00000002   0x40C8             LSRS     R0,R0,R1
   \   00000004   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000006   0x4770             BX       LR               ;; return
    425          }
    426          
    427          /*
    428          * PORTA--PORTE中断处理函数
    429          * 与启动文件startup_K60.s中的中断向量表关联
    430          * 用户无需修改，程序自动进入对应通道中断函数
    431          */

   \                                 In section .text, align 2, keep-with-next
    432          void PORTA_IRQHandler(void)
    433          {
   \                     PORTA_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    434          #if (UCOS_II > 0u)
    435            OS_CPU_SR  cpu_sr = 0u;
    436            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    437            OSIntEnter();
    438            OS_EXIT_CRITICAL();
    439          #endif
    440            
    441            //调用用户自定义中断服务
    442            GPIO_ISR[0](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    443            PORTA->ISFR =0xFFFFFFFF;
   \   00000008   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_13  ;; 0x400490a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    444            
    445          #if (UCOS_II > 0u)
    446            OSIntExit();          //告知系统此时即将离开中断服务子函数
    447          #endif
    448          }//           ;87:  PORT A interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    449          

   \                                 In section .text, align 2, keep-with-next
    450          void PORTB_IRQHandler(void)
    451          {
   \                     PORTB_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    452          #if (UCOS_II > 0u)
    453            OS_CPU_SR  cpu_sr = 0u;
    454            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    455            OSIntEnter();
    456            OS_EXIT_CRITICAL();
    457          #endif
    458            
    459            //调用用户自定义中断服务
    460            GPIO_ISR[1](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x6840             LDR      R0,[R0, #+4]
   \   00000006   0x4780             BLX      R0
    461            PORTB->ISFR =0xFFFFFFFF;
   \   00000008   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_14  ;; 0x4004a0a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    462            
    463          #if (UCOS_II > 0u)
    464            OSIntExit();          //告知系统此时即将离开中断服务子函数
    465          #endif
    466          }//           ;88:  PORT B interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    467          

   \                                 In section .text, align 2, keep-with-next
    468          void PORTC_IRQHandler(void)
    469          {
   \                     PORTC_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    470          #if (UCOS_II > 0u)
    471            OS_CPU_SR  cpu_sr = 0u;
    472            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    473            OSIntEnter();
    474            OS_EXIT_CRITICAL();
    475          #endif
    476            
    477            //调用用户自定义中断服务
    478            GPIO_ISR[2](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x6880             LDR      R0,[R0, #+8]
   \   00000006   0x4780             BLX      R0
    479            PORTC->ISFR =0xFFFFFFFF;
   \   00000008   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_15  ;; 0x4004b0a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    480            
    481          #if (UCOS_II > 0u)
    482            OSIntExit();          //告知系统此时即将离开中断服务子函数
    483          #endif
    484          }//           ;89:  PORT C interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    485          

   \                                 In section .text, align 2, keep-with-next
    486          void PORTD_IRQHandler(void)
    487          {
   \                     PORTD_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    488          #if (UCOS_II > 0u)
    489            OS_CPU_SR  cpu_sr = 0u;
    490            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    491            OSIntEnter();
    492            OS_EXIT_CRITICAL();
    493          #endif
    494            
    495            //调用用户自定义中断服务
    496            GPIO_ISR[3](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x68C0             LDR      R0,[R0, #+12]
   \   00000006   0x4780             BLX      R0
    497            PORTD->ISFR =0xFFFFFFFF;
   \   00000008   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_16  ;; 0x4004c0a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    498            
    499          #if (UCOS_II > 0u)
    500            OSIntExit();          //告知系统此时即将离开中断服务子函数
    501          #endif
    502          }//           ;90:  PORT D interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return
    503          

   \                                 In section .text, align 2, keep-with-next
    504          void PORTE_IRQHandler(void)
    505          {
   \                     PORTE_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    506          #if (UCOS_II > 0u)
    507            OS_CPU_SR  cpu_sr = 0u;
    508            OS_ENTER_CRITICAL(); //告知系统此时已经进入了中断服务子函数
    509            OSIntEnter();
    510            OS_EXIT_CRITICAL();
    511          #endif
    512            
    513            //调用用户自定义中断服务
    514            GPIO_ISR[4](); 
   \   00000002   0x....             LDR.N    R0,??DataTable9_12
   \   00000004   0x6900             LDR      R0,[R0, #+16]
   \   00000006   0x4780             BLX      R0
    515            PORTE->ISFR =0xFFFFFFFF;
   \   00000008   0xF05F 0x30FF      MOVS     R0,#-1
   \   0000000C   0x....             LDR.N    R1,??DataTable9_17  ;; 0x4004d0a0
   \   0000000E   0x6008             STR      R0,[R1, #+0]
    516            
    517          #if (UCOS_II > 0u)
    518            OSIntExit();          //告知系统此时即将离开中断服务子函数
    519          #endif
    520          }//           ;91:  PORT E interrupt
   \   00000010   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x400FF000         DC32     0x400ff000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x40049000         DC32     0x40049000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x400FF040         DC32     0x400ff040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x4004A000         DC32     0x4004a000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x400FF080         DC32     0x400ff080

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x4004B000         DC32     0x4004b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x400FF0C0         DC32     0x400ff0c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x4004C000         DC32     0x4004c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x400FF100         DC32     0x400ff100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x4004D000         DC32     0x4004d000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x........         DC32     GPIO_ISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x400490A0         DC32     0x400490a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x4004A0A0         DC32     0x4004a0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0x4004B0A0         DC32     0x4004b0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0x4004C0A0         DC32     0x4004c0a0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0x4004D0A0         DC32     0x4004d0a0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   GPIO
      24   LPLD_GPIO_DisableIrq
        24   -> NVIC_DisableIRQ
      24   LPLD_GPIO_EnableIrq
        24   -> NVIC_EnableIRQ
      32   LPLD_GPIO_Init
       0   LPLD_GPIO_Input
       0   LPLD_GPIO_Input_8b
       0   LPLD_GPIO_Input_b
       0   LPLD_GPIO_Output
       4   LPLD_GPIO_Output_8b
       4   LPLD_GPIO_Output_b
       0   LPLD_GPIO_Toggle
       0   LPLD_GPIO_Toggle_8b
       0   LPLD_GPIO_Toggle_b
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
       8   PORTA_IRQHandler
         8   -- Indirect call
       8   PORTB_IRQHandler
         8   -- Indirect call
       8   PORTC_IRQHandler
         8   -- Indirect call
       8   PORTD_IRQHandler
         8   -- Indirect call
       8   PORTE_IRQHandler
         8   -- Indirect call


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
      66  GPIO
      20  GPIOX
      20  GPIO_ISR
      64  LPLD_GPIO_DisableIrq
      64  LPLD_GPIO_EnableIrq
     166  LPLD_GPIO_Init
       4  LPLD_GPIO_Input
       8  LPLD_GPIO_Input_8b
      10  LPLD_GPIO_Input_b
       4  LPLD_GPIO_Output
      24  LPLD_GPIO_Output_8b
      24  LPLD_GPIO_Output_b
       4  LPLD_GPIO_Toggle
      10  LPLD_GPIO_Toggle_8b
      10  LPLD_GPIO_Toggle_b
      20  NVIC_DisableIRQ
      20  NVIC_EnableIRQ
      18  PORTA_IRQHandler
      18  PORTB_IRQHandler
      18  PORTC_IRQHandler
      18  PORTD_IRQHandler
      18  PORTE_IRQHandler

 
  20 bytes in section .bss
  20 bytes in section .data
 660 bytes in section .text
 
 660 bytes of CODE memory
  40 bytes of DATA memory

Errors: none
Warnings: none
